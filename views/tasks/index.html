<style>
  .sv-page__grid {
    padding: 5px 20px;
  }

  /* Root container for the plugin */
  .sv-tasks {
    display: flex;
    flex-direction: column;
    gap: var(--space-m);
    padding-block: var(--space-m);
  }

  .sv-tasks__toolbar {
    margin-bottom: var(--space-s);
  }

  /* Horizontal board of columns */
  .sv-tasks__board {
    display: flex;
    flex-direction: row;
    align-items: stretch;
    gap: var(--space-m);
    overflow-x: auto;
    padding-bottom: var(--space-xs);
  }

  /* List column */
  .sv-tasks__list {
    background: #ffffff;
    border-radius: var(--radius-m);
    box-shadow: var(--shadow-s);
    border: 1px solid var(--color-border-primary);
    min-width: 300px;
    max-width: 360px;
    padding: var(--space-s);
    box-sizing: border-box;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    /* Make columns reach closer to the bottom of the viewport */
    height: calc(100vh - 155px);
  }

  .sv-tasks__list--dragging {
    opacity: 0.9;
    box-shadow: var(--shadow-m);
    transform: translateY(-1px);
  }

  .sv-tasks__list-header {
    margin-bottom: var(--space-s);
    position: relative;
  }

  .sv-tasks__list-menu-button {
    font-size: 1.1rem;
    min-width: 28px;
    min-height: 28px;
  }

  .sv-tasks__list-menu {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: var(--space-2xs);
    background: #ffffff;
    border-radius: var(--radius-s);
    box-shadow: var(--shadow-m);
    border: 1px solid var(--color-border-primary);
    min-width: 180px;
    z-index: 20;
    padding: var(--space-2xs) 0;
    overflow: hidden;
  }

  .sv-tasks__list-menu-item {
    width: 100%;
    padding: var(--space-2xs) var(--space-s);
    font-size: 0.8rem;
    text-align: left;
    background: transparent;
    border: none;
    cursor: pointer;
    color: var(--color-text-primary);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .sv-tasks__list-menu-item:hover {
    background: var(--color-bg-secondary);
  }

  .sv-tasks__list-menu-item[data-variant="danger"] {
    color: var(--color-status-danger, #c0392b);
  }

  .sv-tasks__list-menu-item[data-variant="danger"]:hover {
    background: rgba(192, 57, 43, 0.06);
  }

  .sv-tasks__list-menu-divider {
    height: 1px;
    margin: var(--space-3xs) 0;
    background: var(--color-border-subtle, #eeeeee);
  }

  .sv-tasks__list-title {
    font-weight: 600;
  }

  .sv-tasks__list-title-input {
    font: inherit;
    color: var(--color-text-primary);
    border-radius: var(--radius-s);
    border: 1px solid var(--color-border-primary);
    padding: 0 var(--space-2xs);
    width: 100%;
    background: transparent;
  }

  .sv-tasks__list-body {
    min-height: 40px;
    /* small target even when empty */
    margin-bottom: var(--space-s);
    flex: 1;
    overflow-y: auto;
    padding-bottom: var(--space-s);
  }

  /* Task cards */
  .sv-tasks__task-card {
    background: #ffffff;
    border-radius: var(--radius-s);
    border: 1px solid var(--color-border-primary);
    padding: var(--space-2xs) var(--space-xs);
    box-sizing: border-box;
    cursor: grab;
    transition: background-color 120ms ease, box-shadow 120ms ease, transform 120ms ease;
  }

  .sv-tasks__task-card+.sv-tasks__task-card {
    margin-top: var(--space-2xs);
  }

  .sv-tasks__task-card:hover {
    background: var(--color-bg-muted);
  }

  .sv-tasks__task-card--dragging {
    opacity: 0.9;
    box-shadow: var(--shadow-m);
    transform: translateY(-1px);
  }

  .sv-tasks__task-main {
    align-items: center;
  }

  .sv-tasks__task-checkbox {
    margin-right: var(--space-2xs);
  }

  .sv-tasks__task-star {
    margin-right: var(--space-2xs);
    font-size: 0.85rem;
  }

  .sv-tasks__task-delete {
    margin-left: auto;
    font-size: 0.8rem;
  }

  .sv-tasks__task-title {
    font-size: 0.875rem;
    color: var(--color-text-primary);
  }

  .sv-tasks__task-meta {
    font-size: 0.75rem;
    color: var(--color-text-secondary);
  }

  /* Completed state */
  .sv-tasks__task-card--completed .sv-tasks__task-title {
    text-decoration: line-through;
    color: var(--color-text-secondary);
  }

  .sv-tasks__task-card--completed {
    opacity: 0.6;
  }

  .sv-tasks__task-card--starred .sv-tasks__task-title {
    font-weight: 600;
  }

  .sv-tasks__task-card--starred .sv-tasks__task-star {
    color: var(--color-accent-primary);
  }

  .sv-tasks__filter-button {
    border-radius: var(--radius-s);
    border: 1px solid transparent;
    padding: 0 var(--space-xs);
    font-size: 0.8rem;
    line-height: 1.8;
    cursor: pointer;
    background: transparent;
    color: var(--color-text-secondary);
  }

  .sv-tasks__filter-button--active {
    border-color: var(--color-border-primary);
    background: var(--color-bg-secondary);
    color: var(--color-text-primary);
  }

  /* Add-task input */
  .sv-tasks__add-task-input {
    width: 100%;
    box-sizing: border-box;
    border-radius: var(--radius-s);
    border: 1px dashed var(--color-border-primary);
    padding: var(--space-2xs) var(--space-xs);
    font-size: 0.875rem;
  }

  .sv-tasks__add-task {
    margin-bottom: var(--space-s);
  }

  /* Add-list column */
  .sv-tasks__add-list {
    min-width: 260px;
    max-width: 320px;
    flex-shrink: 0;
    box-sizing: border-box;
    border-radius: var(--radius-m);
    border: 1px dashed var(--color-border-primary);
    padding: var(--space-s);
    display: flex;
    flex-direction: column;
    align-items: stretch;
    justify-content: flex-start;
  }

  .sv-tasks__modal-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }

  .sv-tasks__modal {
    background: var(--color-surface, #ffffff);
    border-radius: var(--radius-l, 8px);
    box-shadow: var(--shadow-l);
    min-width: 320px;
    max-width: 480px;
    padding: var(--space-m);
    box-sizing: border-box;
  }

  .sv-tasks__modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: var(--space-s);
  }

  .sv-tasks__modal-title {
    font-size: 1rem;
    font-weight: 600;
  }

  .sv-tasks__modal-close {
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 1.1rem;
    line-height: 1;
  }

  .sv-tasks__modal-body {
    display: flex;
    flex-direction: column;
    gap: var(--space-s);
    margin-bottom: var(--space-m);
  }

  .sv-tasks__modal-field {
    display: flex;
    flex-direction: column;
    gap: var(--space-2xs);
  }

  .sv-tasks__modal-label {
    font-size: 0.8rem;
    color: var(--color-text-secondary);
  }

  .sv-tasks__modal-input,
  .sv-tasks__modal-textarea {
    border-radius: var(--radius-s);
    border: 1px solid var(--color-border-primary);
    padding: var(--space-2xs) var(--space-xs);
    font-size: 0.875rem;
    box-sizing: border-box;
  }

  .sv-tasks__modal-textarea {
    min-height: 80px;
    resize: vertical;
  }

  .sv-tasks__modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: var(--space-xs);
  }

  .sv-tasks__modal-footer button {
    border-radius: var(--radius-s);
    border: 1px solid var(--color-border-primary);
    padding: 0 var(--space-s);
    font-size: 0.85rem;
    line-height: 2;
    cursor: pointer;
    background: var(--color-bg-secondary);
  }

  .sv-tasks__modal-footer button[data-role="primary"] {
    background: var(--color-accent-primary);
    color: var(--color-text-primary);
    border-color: var(--color-accent-primary);
  }

  .sv-tasks__list-shared-pill {
    display: inline-block;
    margin-left: var(--space-2xs);
    padding: 0 var(--space-2xs);
    border-radius: var(--radius-pill, 999px);
    font-size: 0.7rem;
    background: var(--color-bg-secondary);
    color: var(--color-text-secondary);
  }

  .sv-tasks__share-invite-list {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .sv-tasks__share-invite-item {
    display: flex;
    justify-content: space-between;
    font-size: 0.8rem;
    padding-block: 2px;
  }

  .sv-tasks__share-invite-email {
    flex: 1;
    margin-right: var(--space-2xs);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .sv-tasks__share-invite-status {
    font-size: 0.75rem;
    color: var(--color-text-secondary);
  }

  .sv-tasks__share-invite-empty {
    font-size: 0.8rem;
    color: var(--color-text-secondary);
    font-style: italic;
  }
</style>
<div class="sv-page__wrap--full">
  <section class="sv-page__grid">
    <div id="sv-tasks-root" class="sv-tasks" data-user-id="{{tasksUserId}}">
      <!-- Board toolbar (reserved for future use) -->
      <div class="sv-tasks__toolbar flex row align-items-center flex-space-between">
        <div class="sv-tasks__toolbar-left flex row gap-s">
          <span class="sv-h-5">My lists</span>
        </div>
        <div class="sv-tasks__toolbar-right flex row gap-xs">
          <button type="button" class="sv-tasks__filter-button" data-filter="all">All</button>
          <button type="button" class="sv-tasks__filter-button" data-filter="active">Active</button>
          <button type="button" class="sv-tasks__filter-button" data-filter="completed">Completed</button>
        </div>
      </div>

      <!-- Kanban board: lists row -->
      <div class="sv-tasks__board flex row gap-m" data-role="board">
        <!-- Lists will be rendered here by render() -->

        <!-- Example list column (for reference only, will be generated in JS) -->
        <!--
        <article class="sv-tasks__list" data-list-id="1">
          <header class="sv-tasks__list-header flex row align-items-center flex-space-between">
            <h2 class="sv-h-5 sv-tasks__list-title">Inbox</h2>
            <button
              class="sv-icon-button sv-tasks__list-menu-button"
              type="button"
              data-action="open-list-menu"
              aria-label="List actions"
            >
              ⋯
            </button>
          </header>

          <div class="sv-tasks__list-body flex col gap-xs">
            <div
              class="sv-tasks__task-card"
              data-task-id="100"
              draggable="true"
            >
              <div class="sv-tasks__task-main flex row gap-xs align-items-center">
                <input
                  class="sv-tasks__task-checkbox"
                  type="checkbox"
                  data-action="toggle-completed"
                />
                <button
                  class="sv-icon-button sv-tasks__task-star"
                  type="button"
                  data-action="toggle-starred"
                  aria-label="Mark as important"
                >
                  ★
                </button>
                <div class="sv-tasks__task-content flex col gap-2xs">
                  <div class="sv-tasks__task-title">Buy coffee beans</div>
                  <div class="sv-tasks__task-meta">
                    <time datetime="2025-11-15">15 Nov</time>
                    <!-- future: recurrence icon, list name, etc. -->
      </div>
    </div>
</div>
</div>
</div>
</article>
</div>
</div>
</section>
</div>

<script>
  (function () {
    function nowISO() {
      return new Date().toISOString();
    }

    function formatDueDateDisplay(value) {
      if (!value) return '';

      var date;
      try {
        // Try direct parsing first
        date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          // Fallback for plain YYYY-MM-DD
          var parts = String(value).split('-');
          if (parts.length === 3) {
            var year = Number(parts[0]);
            var month = Number(parts[1]) - 1;
            var day = Number(parts[2]);
            date = new Date(year, month, day);
          }
        }
      } catch (e) {
        return String(value);
      }

      if (!date || Number.isNaN(date.getTime())) {
        return String(value);
      }

      var today = new Date();
      var todayMid = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
      var dateMid = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
      var diffDays = Math.round((dateMid - todayMid) / 86400000); // 24 * 60 * 60 * 1000

      if (diffDays === 0) return 'Today';
      if (diffDays === 1) return 'Tomorrow';
      if (diffDays === -1) return 'Yesterday';

      // For near future / recent past, show weekday
      var options;
      if (Math.abs(diffDays) <= 7) {
        options = { weekday: 'short', day: 'numeric', month: 'short' };
      } else {
        options = { day: 'numeric', month: 'short', year: 'numeric' };
      }

      try {
        return date.toLocaleDateString(undefined, options);
      } catch (e) {
        // Fallback if locale fails
        var dd = String(date.getDate()).padStart(2, '0');
        var mm = String(date.getMonth() + 1).padStart(2, '0');
        var yyyy = date.getFullYear();
        return yyyy + '-' + mm + '-' + dd;
      }
    }

    // --- Date helpers for recurrence ---
    function parseDateFlexible(value) {
      if (!value) return null;
      var date;
      try {
        date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          var parts = String(value).split('-');
          if (parts.length === 3) {
            var year = Number(parts[0]);
            var month = Number(parts[1]) - 1;
            var day = Number(parts[2]);
            date = new Date(year, month, day);
          }
        }
      } catch (e) {
        return null;
      }
      if (!date || Number.isNaN(date.getTime())) {
        return null;
      }
      return date;
    }

    function addDays(date, days) {
      var d = new Date(date.getTime());
      d.setDate(d.getDate() + days);
      return d;
    }

    function addMonths(date, months) {
      var d = new Date(date.getTime());
      var day = d.getDate();
      d.setDate(1);
      d.setMonth(d.getMonth() + months);
      var y = d.getFullYear();
      var m = d.getMonth();
      var daysInMonth = new Date(y, m + 1, 0).getDate();
      d.setDate(Math.min(day, daysInMonth));
      return d;
    }

    function addYears(date, years) {
      var d = new Date(date.getTime());
      d.setFullYear(d.getFullYear() + years);
      return d;
    }

    function computeNextDueDate(currentDate, recurring) {
      if (!recurring || !currentDate) return null;

      var r = recurring;

      function fromPreset(preset) {
        if (!preset) return null;
        if (preset === 'daily') return addDays(currentDate, 1);
        if (preset === 'weekly') return addDays(currentDate, 7);
        if (preset === 'monthly') return addMonths(currentDate, 1);
        if (preset === 'yearly') return addYears(currentDate, 1);
        if (preset === 'weekday') {
          // Next weekday (Mon–Fri)
          var d = addDays(currentDate, 1);
          while (d.getDay() === 0 || d.getDay() === 6) {
            d = addDays(d, 1);
          }
          return d;
        }
        return null;
      }

      // Legacy string form
      if (typeof r === 'string') {
        return fromPreset(r);
      }

      if (typeof r !== 'object') return null;

      if (r.kind === 'preset') {
        return fromPreset(r.preset);
      }

      if (r.kind === 'custom' && r.custom) {
        var interval = r.custom.interval || 1;
        var unit = r.custom.unit || 'day';
        if (interval < 1) interval = 1;

        if (unit === 'day') return addDays(currentDate, interval);
        if (unit === 'week') return addDays(currentDate, interval * 7);
        if (unit === 'month') return addMonths(currentDate, interval);
        if (unit === 'year') return addYears(currentDate, interval);
      }

      return null;
    }

    var STORAGE_USER_ID = (function () {
      var root = document.getElementById('sv-tasks-root');
      if (root && root.dataset && typeof root.dataset.userId === 'string' && root.dataset.userId.trim()) {
        return root.dataset.userId.trim();
      }
      if (typeof window !== 'undefined' && window && typeof window.__SV_TASKS_USER_ID__ === 'string') {
        return window.__SV_TASKS_USER_ID__;
      }
      return '';
    })();
    var STORAGE_KEY = 'sv:tasks:' + (STORAGE_USER_ID ? ('user:' + STORAGE_USER_ID) : 'anon') + ':state:v1';
    var CURRENT_VERSION = '0.1.1';

    // --- Sync helpers ---
    function isOnline() {
      try {
        if (typeof navigator === 'undefined' || !navigator) return true;
        // offline-first: if the browser explicitly says "offline", don't hit the server
        return navigator.onLine !== false;
      } catch (e) {
        return true;
      }
    }

    function syncRequest(path, method, body) {
      if (typeof fetch !== 'function') return;
      if (!isOnline()) return;

      var opts = {
        method: method || 'GET',
        headers: {
          'Accept': 'application/json',
        },
        credentials: 'same-origin',
      };

      if (typeof body !== 'undefined') {
        opts.headers['Content-Type'] = 'application/json';
        opts.body = JSON.stringify(body);
      }

      try {
        fetch(path, opts).catch(function () {
          // swallow errors: offline-first
        });
      } catch (e) {
        // ignore unexpected environments
      }
    }

    function syncCreateList(list) {
      if (!list) return;
      if (typeof fetch !== 'function') return;
      if (!isOnline()) return;

      var payload = {
        name: list.name,
        slug: list.slug,
        // Let the server know our local id so we can map later if needed
        clientId: list.id,
      };

      try {
        fetch('/api/plugins/tasks/lists', {
          method: 'POST',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          credentials: 'same-origin',
          body: JSON.stringify(payload),
        })
          .then(function (res) {
            if (!res || !res.ok) return null;
            return res.json();
          })
          .then(function (created) {
            if (!created || typeof created.id === 'undefined') return;

            var state = window.$state;
            if (!state || !state.data || !state.data.lists) return;

            var localList = state.data.lists[list.id];
            if (!localList) return;

            // Store remote id on the list
            localList.remoteId = created.id;

            // Also track in sync.remoteListIds map
            if (!state.sync || typeof state.sync !== 'object') {
              state.sync = { lastServerBootstrapAt: null, remoteListIds: {} };
            }
            if (!state.sync.remoteListIds || typeof state.sync.remoteListIds !== 'object') {
              state.sync.remoteListIds = {};
            }
            state.sync.remoteListIds[localList.id] = created.id;

            touchUpdatedAt();
            saveState();
          })
          .catch(function () {
            // ignore network or parsing issues to preserve offline-first behaviour
          });
      } catch (e) {
        // ignore environments without fetch or unexpected failures
      }
    }

    function syncUpdateList(list) {
      if (!list || typeof list.id === 'undefined') return;
      var state = window.$state;
      var remoteId = list.remoteId;

      if ((!remoteId || Number.isNaN(Number(remoteId))) && state && state.sync && state.sync.remoteListIds) {
        var mapped = state.sync.remoteListIds[list.id];
        if (mapped) {
          remoteId = mapped;
        }
      }

      if (!remoteId) return;

      syncRequest('/api/plugins/tasks/lists/' + remoteId, 'PUT', {
        name: list.name,
        slug: list.slug,
      });
    }

    function syncDeleteList(listId) {
      if (!listId) return;
      var state = window.$state;
      var numericId = Number(listId);
      var lists = state && state.data && state.data.lists ? state.data.lists : null;
      var list = lists && lists[numericId] ? lists[numericId] : null;
      var remoteId = list && list.remoteId;

      if ((!remoteId || Number.isNaN(Number(remoteId))) && state && state.sync && state.sync.remoteListIds) {
        var mapped = state.sync.remoteListIds[numericId];
        if (mapped) {
          remoteId = mapped;
        }
      }

      if (!remoteId) return;

      syncRequest('/api/plugins/tasks/lists/' + remoteId, 'DELETE');
    }

    function syncCreateTask(task) {
      if (!task) return;
      if (typeof fetch !== 'function') return;
      if (!isOnline()) return;

      var state = window.$state;
      if (!state || !state.data || !state.data.lists) return;

      var lists = state.data.lists;
      var localList = lists[task.listId];
      if (!localList) return;

      var remoteListId = localList.remoteId;
      if ((!remoteListId || Number.isNaN(Number(remoteListId))) && state.sync && state.sync.remoteListIds) {
        var mapped = state.sync.remoteListIds[localList.id];
        if (mapped) {
          remoteListId = mapped;
        }
      }

      // If we still don't know the remote list id, we can't safely sync this task yet.
      if (!remoteListId) return;

      var payload = {
        listId: remoteListId,
        title: task.title,
        description: task.description,
        dueDate: task.dueDate,
        recurringConfig: task.recurring || null,
        starred: !!task.starred,
      };

      try {
        fetch('/api/plugins/tasks', {
          method: 'POST',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          credentials: 'same-origin',
          body: JSON.stringify(payload),
        })
          .then(function (res) {
            if (!res || !res.ok) return null;
            return res.json();
          })
          .then(function (created) {
            if (!created || typeof created.id === 'undefined') return;

            var st = window.$state;
            if (!st || !st.data || !st.data.tasks) return;

            var localTask = st.data.tasks[task.id];
            if (!localTask) return;

            // Remember remote ids so later updates/deletes use the server's primary keys
            localTask.remoteId = created.id;
            localTask.remoteListId = remoteListId;

            touchUpdatedAt();
            saveState();
          })
          .catch(function () {
            // ignore network or parsing errors; offline-first behaviour
          });
      } catch (e) {
        // ignore unexpected failures
      }
    }

    function syncUpdateTask(task) {
      if (!task || typeof task.id === 'undefined') return;

      var state = window.$state;
      var remoteTaskId = (typeof task.remoteId !== 'undefined' && task.remoteId !== null)
        ? task.remoteId
        : task.id; // for tasks that originated from the server

      if (!remoteTaskId) return;

      var lists = state && state.data && state.data.lists ? state.data.lists : null;
      var localList = lists && lists[task.listId] ? lists[task.listId] : null;

      var remoteListId = task.remoteListId || (localList && localList.remoteId) || null;
      if ((!remoteListId || Number.isNaN(Number(remoteListId))) && state && state.sync && state.sync.remoteListIds && localList) {
        var mapped = state.sync.remoteListIds[localList.id];
        if (mapped) {
          remoteListId = mapped;
        }
      }

      var body = {
        title: task.title,
        description: task.description,
        dueDate: task.dueDate,
        recurringConfig: task.recurring || null,
        completed: !!task.completed,
        starred: !!task.starred,
      };

      // Only include listId in the payload if we know the remote list id
      if (remoteListId) {
        body.listId = remoteListId;
      }

      syncRequest('/api/plugins/tasks/' + remoteTaskId, 'PUT', body);
    }

    function syncDeleteTask(taskId) {
      if (!taskId) return;
      var state = window.$state;
      var numericId = Number(taskId);
      var tasks = state && state.data && state.data.tasks ? state.data.tasks : null;
      var task = tasks && tasks[numericId] ? tasks[numericId] : null;

      var remoteTaskId = task && (typeof task.remoteId !== 'undefined' && task.remoteId !== null)
        ? task.remoteId
        : numericId; // fallback for tasks that came from the server

      if (!remoteTaskId) return;

      syncRequest('/api/plugins/tasks/' + remoteTaskId, 'DELETE');
    }

    function syncDeleteCompletedTasks(listId) {
      if (!listId) return;
      syncRequest('/api/plugins/tasks/lists/' + listId + '/completed', 'DELETE');
    }

    function canUseLocalStorage() {
      try {
        return typeof window !== 'undefined' && 'localStorage' in window && window.localStorage != null;
      } catch (e) {
        return false;
      }
    }

    function createDefaultState() {
      const now = nowISO();
      return {
        meta: {
          createdAt: now,
          updatedAt: now,
          version: CURRENT_VERSION,
        },
        data: {
          lists: {
            1: {
              id: 1,
              name: 'Inbox',
              slug: 'inbox',
              createdAt: now,
              updatedAt: now,
              remoteId: null,
            },
          },
          tasks: {},
          taskIdsByListId: {
            1: [],
          },
          listOrder: [1],
          shareInvitesByListId: {},
        },
        ui: {
          taskFilter: 'all',
        },
        sync: {
          lastServerBootstrapAt: null,
        },
      };
    }

    function migrateState(state) {
      if (!state || typeof state !== 'object') {
        return createDefaultState();
      }

      var now = nowISO();

      // Ensure meta
      if (!state.meta || typeof state.meta !== 'object') {
        state.meta = {
          createdAt: now,
          updatedAt: now,
          version: CURRENT_VERSION,
        };
      } else {
        if (!state.meta.createdAt) state.meta.createdAt = now;
        if (!state.meta.updatedAt) state.meta.updatedAt = now;
      }

      // Ensure data
      if (!state.data || typeof state.data !== 'object') {
        return createDefaultState();
      }

      var data = state.data;

      // Ensure tasks
      if (!data.tasks || typeof data.tasks !== 'object') {
        data.tasks = {};
      }

      // Migrate legacy recurring values on tasks (string -> structured object)
      Object.keys(data.tasks).forEach(function (taskId) {
        var task = data.tasks[taskId];
        if (!task || typeof task !== 'object') return;

        var r = task.recurring;
        if (!r) {
          task.recurring = null;
          return;
        }

        // If it's already a structured object, normalise it
        if (typeof r === 'object') {
          if (r.kind === 'custom') {
            if (!r.custom || typeof r.custom !== 'object') {
              r.custom = {
                interval: 1,
                unit: 'day',
                ends: { type: 'never' },
              };
            } else {
              if (typeof r.custom.interval !== 'number' || r.custom.interval <= 0) {
                r.custom.interval = 1;
              }
              if (!r.custom.unit) {
                r.custom.unit = 'day';
              }
              if (!r.custom.ends || typeof r.custom.ends !== 'object') {
                r.custom.ends = { type: 'never' };
              }
            }
          }
          task.recurring = r;
          return;
        }

        // Legacy string values like 'daily', 'weekly'
        if (typeof r === 'string') {
          if (r === 'daily' || r === 'weekly' || r === 'monthly' || r === 'yearly' || r === 'weekday') {
            task.recurring = {
              kind: 'preset',
              preset: r,
            };
          } else {
            // Unknown string; best effort: drop recurrence
            task.recurring = null;
          }
        }
      });

      // Ensure remoteId and remoteListId for tasks
      Object.keys(data.tasks).forEach(function (taskId) {
        var task = data.tasks[taskId];
        if (!task || typeof task !== 'object') return;
        if (typeof task.remoteId === 'undefined') {
          // For tasks that may have come from the server, default remoteId to id when not present
          task.remoteId = task.id != null ? task.id : null;
        }
        if (typeof task.remoteListId === 'undefined') {
          task.remoteListId = null;
        }
      });

      // Ensure lists
      if (!data.lists || Object.keys(data.lists).length === 0) {
        var fresh = createDefaultState();
        return fresh;
      }

      // Ensure remoteId for lists
      Object.keys(data.lists).forEach(function (id) {
        var list = data.lists[id];
        if (!list || typeof list !== 'object') return;
        if (typeof list.remoteId === 'undefined') {
          list.remoteId = null;
        }
      });

      // Ensure taskIdsByListId exists and has entries for every list
      if (!data.taskIdsByListId || typeof data.taskIdsByListId !== 'object') {
        data.taskIdsByListId = {};
      }
      Object.keys(data.lists).forEach(function (id) {
        var numericId = Number(id);
        if (!data.taskIdsByListId[numericId]) {
          data.taskIdsByListId[numericId] = [];
        }
      });

      // Ensure listOrder
      if (!Array.isArray(data.listOrder) || data.listOrder.length === 0) {
        data.listOrder = Object.keys(data.lists)
          .map(function (id) { return Number(id); })
          .filter(function (n) { return !Number.isNaN(n); });
      }

      // Ensure shareInvitesByListId
      if (!data.shareInvitesByListId || typeof data.shareInvitesByListId !== 'object') {
        data.shareInvitesByListId = {};
      }

      // Ensure ui
      if (!state.ui || typeof state.ui !== 'object') {
        state.ui = { taskFilter: 'all' };
      } else {
        if (!state.ui.taskFilter) {
          state.ui.taskFilter = 'all';
        }
      }

      // Ensure sync
      if (!state.sync || typeof state.sync !== 'object') {
        state.sync = {
          lastServerBootstrapAt: null,
          remoteListIds: {},
        };
      } else {
        if (typeof state.sync.lastServerBootstrapAt === 'undefined') {
          state.sync.lastServerBootstrapAt = null;
        }
        if (!state.sync.remoteListIds || typeof state.sync.remoteListIds !== 'object') {
          state.sync.remoteListIds = {};
        }
      }

      // Bump version
      state.meta.version = CURRENT_VERSION;
      // Do not overwrite createdAt; updatedAt will be refreshed on next mutation
      return state;
    }

    function isLikelyEmptyState(state) {
      if (!state || !state.data || !state.data.lists) return true;
      var lists = state.data.lists;
      var listIds = Object.keys(lists);
      if (listIds.length !== 1) return false;

      var onlyList = lists[listIds[0]];
      var name = (onlyList && onlyList.name) || '';
      var slug = (onlyList && onlyList.slug) || '';

      var isInbox =
        slug === 'inbox' ||
        /^inbox$/i.test(name.trim());

      var tasks = state.data.tasks || {};
      var anyTasks = Object.keys(tasks).length > 0;

      return isInbox && !anyTasks;
    }

    function saveState() {
      if (!canUseLocalStorage()) return;
      try {
        var raw = JSON.stringify(window.$state || {});
        window.localStorage.setItem(STORAGE_KEY, raw);
      } catch (e) {
        // ignore storage errors in Phase-1
      }
    }

    function loadState() {
      if (!canUseLocalStorage()) return null;
      try {
        var raw = window.localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        var parsed = JSON.parse(raw);
        // minimal shape check
        if (!parsed || !parsed.data || !parsed.data.lists) return null;
        return migrateState(parsed);
      } catch (e) {
        return null;
      }
    }

    function touchUpdatedAt() {
      if (!window.$state || !window.$state.meta) return;
      window.$state.meta.updatedAt = nowISO();
      saveState();
    }

    function focusAddTaskInput(listId) {
      var root = document.getElementById('sv-tasks-root');
      if (!root) return;
      var board = root.querySelector('[data-role="board"]');
      if (!board) return;
      var selector = '.sv-tasks__list[data-list-id="' + String(listId) + '"] .sv-tasks__add-task-input';
      var input = board.querySelector(selector);
      if (input) {
        input.focus();
      }
    }

    function nextNumericId(map) {
      const keys = Object.keys(map || {});
      if (!keys.length) return 1;
      const numeric = keys
        .map(function (k) { return Number(k); })
        .filter(function (n) { return !Number.isNaN(n); });
      if (!numeric.length) return 1;
      return Math.max.apply(null, numeric) + 1;
    }

    function initState() {
      // If state already exists in memory, keep it
      if (window.$state && window.$state.data && window.$state.data.lists) {
        return;
      }

      // Try to load from localStorage (and migrate if needed)
      var loaded = loadState();
      if (loaded && loaded.data && loaded.data.lists) {
        window.$state = loaded;
        // Ensure we persist any migration changes
        saveState();
        return;
      }

      // Fallback: create a fresh default state
      window.$state = createDefaultState();

      // Persist the default state immediately
      saveState();
    }

    function renameList(listId, newName) {
      var state = window.$state;
      if (!state || !state.data || !state.data.lists) return;

      var lists = state.data.lists;
      var numericId = Number(listId);
      var list = lists[numericId];
      if (!list) return;

      var trimmed = (newName || '').trim();
      if (!trimmed || trimmed === list.name) {
        // No change; just re-render to exit edit mode
        render();
        return;
      }

      list.name = trimmed;
      list.slug = trimmed.toLowerCase().replace(/\s+/g, '-');
      list.updatedAt = nowISO();
      touchUpdatedAt();
      render();

      // Best-effort sync
      syncUpdateList(list);
    }

    function addList(name) {
      var state = window.$state;
      if (!state || !state.data) return;
      var trimmed = (name || '').trim();
      if (!trimmed) return;

      var lists = state.data.lists || {};
      var taskIdsByListId = state.data.taskIdsByListId || {};
      var listOrder = state.data.listOrder || [];

      var id = nextNumericId(lists);
      var now = nowISO();

      lists[id] = {
        id: id,
        name: trimmed,
        slug: trimmed.toLowerCase().replace(/\s+/g, '-'),
        createdAt: now,
        updatedAt: now,
        remoteId: null,
      };

      taskIdsByListId[id] = [];
      listOrder.push(id);

      state.data.lists = lists;
      state.data.taskIdsByListId = taskIdsByListId;
      state.data.listOrder = listOrder;

      touchUpdatedAt();
      render();
      // Best-effort sync to server
      syncCreateList(lists[id]);
    }
    function setTaskFilter(filter) {
      var state = window.$state;
      if (!state || !state.ui) return;
      if (!filter) return;
      state.ui.taskFilter = filter;
      touchUpdatedAt();
      render();
      applyTaskFilterUI();
    }

    function applyTaskFilterUI() {
      var root = document.getElementById('sv-tasks-root');
      if (!root) return;
      var buttons = root.querySelectorAll('.sv-tasks__filter-button');
      var current = (window.$state && window.$state.ui && window.$state.ui.taskFilter) || 'all';
      buttons.forEach(function (btn) {
        if (btn.dataset.filter === current) {
          btn.classList.add('sv-tasks__filter-button--active');
        } else {
          btn.classList.remove('sv-tasks__filter-button--active');
        }
      });
    }

    function addTask(listId, title) {
      var state = window.$state;
      if (!state || !state.data) return;

      var trimmed = (title || '').trim();
      if (!trimmed) return;

      var lists = state.data.lists || {};
      if (!lists[listId]) return; // invalid list id

      var tasks = state.data.tasks || {};
      var taskIdsByListId = state.data.taskIdsByListId || {};
      var listTaskIds = taskIdsByListId[listId] || [];

      var id = nextNumericId(tasks);
      var now = nowISO();

      tasks[id] = {
        id: id,
        listId: listId,
        title: trimmed,
        description: null,
        dueDate: null,
        recurring: null,
        completed: false,
        starred: false,
        createdAt: now,
        updatedAt: now,
      };

      listTaskIds.push(id);
      taskIdsByListId[listId] = listTaskIds;

      state.data.tasks = tasks;
      state.data.taskIdsByListId = taskIdsByListId;

      touchUpdatedAt();
      render();
      // After re-render, focus the add-task input for this list
      focusAddTaskInput(listId);
      // Best-effort sync
      syncCreateTask(tasks[id]);
    }

    function toggleTaskCompleted(taskId) {
      var state = window.$state;
      if (!state || !state.data || !state.data.tasks) return;

      var numericId = Number(taskId);
      var task = state.data.tasks[numericId];
      if (!task) return;

      var wasCompleted = !!task.completed;

      // If un-completing, just flip to false
      if (wasCompleted) {
        task.completed = false;
        task.updatedAt = nowISO();
        touchUpdatedAt();
        syncUpdateTask(task);
        render();
        return;
      }

      // From incomplete -> complete
      var r = task.recurring;
      var hasRecurrence = !!r;
      var hasDueDate = !!task.dueDate;

      // If no recurrence or no due date, behave like a normal task
      if (!hasRecurrence || !hasDueDate) {
        task.completed = true;
        task.updatedAt = nowISO();
        touchUpdatedAt();
        syncUpdateTask(task);
        render();
        return;
      }

      var currentDue = parseDateFlexible(task.dueDate);
      if (!currentDue) {
        // Fallback to simple toggle if due date is invalid
        task.completed = true;
        task.updatedAt = nowISO();
        touchUpdatedAt();
        syncUpdateTask(task);
        render();
        return;
      }

      var nextDate = computeNextDueDate(currentDue, r);
      if (!nextDate) {
        // If we can't compute a next date, fallback to simple completion
        task.completed = true;
        task.updatedAt = nowISO();
        touchUpdatedAt();
        syncUpdateTask(task);
        render();
        return;
      }

      var stopRecurrence = false;

      // Respect custom 'ends' configuration for custom recurrences
      if (typeof r === 'object' && r.kind === 'custom' && r.custom && r.custom.ends) {
        var ends = r.custom.ends;
        var type = ends.type || 'never';

        if (type === 'afterCount') {
          var count = parseInt(ends.count, 10);
          if (!count || count <= 1) {
            // This was the last occurrence
            stopRecurrence = true;
          } else {
            // Decrement remaining occurrences
            ends.count = count - 1;
          }
        } else if (type === 'onDate' && ends.date) {
          var endDate = parseDateFlexible(ends.date);
          if (endDate && nextDate > endDate) {
            // Next occurrence would go beyond the end date
            stopRecurrence = true;
          }
        }
      }

      if (stopRecurrence) {
        // Treat this as the final completion: mark completed and drop recurrence
        task.completed = true;
        task.recurring = null;
        task.updatedAt = nowISO();
        touchUpdatedAt();
        syncUpdateTask(task);
        render();
        return;
      }

      // Otherwise, auto-reschedule: advance due date and keep task active
      task.dueDate = nextDate.toISOString().slice(0, 10); // store as YYYY-MM-DD
      task.completed = false; // stays active
      task.updatedAt = nowISO();
      touchUpdatedAt();
      syncUpdateTask(task);
      render();
    }

    function toggleTaskStarred(taskId) {
      var state = window.$state;
      if (!state || !state.data || !state.data.tasks) return;

      var numericId = Number(taskId);
      var task = state.data.tasks[numericId];
      if (!task) return;

      task.starred = !task.starred;
      task.updatedAt = nowISO();
      touchUpdatedAt();
      syncUpdateTask(task);
      render();
    }

    // --- Task details modal state and helpers ---
    var currentTaskModalId = null;

    // --- Share list modal state and helpers ---
    var currentShareModalListId = null;

    function closeShareListModal() {
      var root = document.getElementById('sv-tasks-root');
      if (!root) return;
      var backdrop = root.querySelector('[data-role="share-list-modal-backdrop"]');
      if (backdrop && backdrop.parentNode) {
        backdrop.parentNode.removeChild(backdrop);
      }
      currentShareModalListId = null;
    }

    function shareListWithEmail(listId, email) {
      var trimmed = (email || '').trim();
      if (!trimmed) {
        if (window.alert) {
          window.alert('Please enter an email address.');
        }
        return;
      }

      // very lightweight email validation
      var simpleEmail = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;
      if (!simpleEmail.test(trimmed)) {
        if (window.alert) {
          window.alert('Please enter a valid email address.');
        }
        return;
      }

      var state = window.$state;
      if (!state || !state.data || !state.data.lists) return;

      var numericId = Number(listId);
      var list = state.data.lists[numericId];
      if (!list) return;

      var remoteId = list.remoteId;
      if ((!remoteId || Number.isNaN(Number(remoteId))) && state.sync && state.sync.remoteListIds) {
        var mapped = state.sync.remoteListIds[list.id];
        if (mapped) {
          remoteId = mapped;
        }
      }

      if (!remoteId) {
        if (window.alert) {
          window.alert('This list has not been synced with the server yet and cannot be shared.');
        }
        return;
      }

      // Best-effort API call; backend implementation will be added later.
      try {
        fetch('/api/plugins/tasks/lists/' + remoteId + '/share', {
          method: 'POST',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          credentials: 'same-origin',
          body: JSON.stringify({ email: trimmed }),
        })
          .then(function (res) {
            if (!res) return null;
            if (!res.ok) {
              // Try to surface basic error information in dev tools only
              return res.json().catch(function () { return null; }).then(function (err) {
                if (window.console && console.warn) {
                  console.warn('[tasks] Share list failed', err || res.statusText);
                }
                return null;
              });
            }
            return res.json().catch(function () { return null; });
          })
          .then(function (result) {
            var stateAfter = window.$state;
            if (stateAfter && stateAfter.data) {
              if (!stateAfter.data.shareInvitesByListId || typeof stateAfter.data.shareInvitesByListId !== 'object') {
                stateAfter.data.shareInvitesByListId = {};
              }
              var listInvites = stateAfter.data.shareInvitesByListId[numericId] || [];
              listInvites = listInvites.slice(); // shallow copy
              listInvites.push({
                id: result && typeof result.inviteId !== 'undefined' ? result.inviteId : null,
                email: trimmed,
                status: (result && result.status) || 'pending',
              });
              stateAfter.data.shareInvitesByListId[numericId] = listInvites;
              try {
                saveState();
              } catch (e) {
                // ignore storage errors
              }
              try {
                render();
              } catch (e) {
                // ignore render errors
              }
            }

            if (window.alert) {
              window.alert('Invitation sent to ' + trimmed + '.');
            }
          })
          .catch(function (err) {
            if (window.console && console.warn) {
              console.warn('[tasks] Share list network error', err);
            }
          });
      } catch (e) {
        // ignore unexpected failures to preserve offline-first behaviour
      }
    }

    function openShareListModal(listId) {
      var state = window.$state;
      if (!state || !state.data || !state.data.lists) return;

      var numericId = Number(listId);
      var list = state.data.lists[numericId];
      if (!list) return;

      // Prevent multiple share modals
      if (currentShareModalListId !== null) {
        closeShareListModal();
      }
      currentShareModalListId = numericId;

      var root = document.getElementById('sv-tasks-root');
      if (!root) return;

      var backdrop = document.createElement('div');
      backdrop.className = 'sv-tasks__modal-backdrop';
      backdrop.dataset.role = 'share-list-modal-backdrop';

      var modal = document.createElement('div');
      modal.className = 'sv-tasks__modal';

      var header = document.createElement('div');
      header.className = 'sv-tasks__modal-header';

      var title = document.createElement('div');
      title.className = 'sv-tasks__modal-title';
      title.textContent = 'Share list';

      var closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.className = 'sv-tasks__modal-close';
      closeBtn.innerHTML = '&times;';
      closeBtn.addEventListener('click', function () {
        closeShareListModal();
      });

      header.appendChild(title);
      header.appendChild(closeBtn);

      var body = document.createElement('div');
      body.className = 'sv-tasks__modal-body';

      var form = document.createElement('form');

      var infoText = document.createElement('p');
      infoText.className = 'sv-tasks__modal-label';
      infoText.textContent = 'Share "' + list.name + '" with another user by email.';

      var fieldEmail = document.createElement('div');
      fieldEmail.className = 'sv-tasks__modal-field';

      var labelEmail = document.createElement('label');
      labelEmail.className = 'sv-tasks__modal-label';
      labelEmail.textContent = 'Email address';

      var inputEmail = document.createElement('input');
      inputEmail.type = 'email';
      inputEmail.className = 'sv-tasks__modal-input';
      inputEmail.placeholder = 'user@example.com';

      fieldEmail.appendChild(labelEmail);
      fieldEmail.appendChild(inputEmail);

      form.appendChild(infoText);
      form.appendChild(fieldEmail);

      // Existing invites list
      var stateForInvites = window.$state;
      var invitesBlock = document.createElement('div');
      invitesBlock.className = 'sv-tasks__modal-field';

      var invites = [];
      if (stateForInvites && stateForInvites.data && stateForInvites.data.shareInvitesByListId) {
        invites = stateForInvites.data.shareInvitesByListId[numericId] || [];
      }

      if (invites.length > 0) {
        var invitesLabel = document.createElement('div');
        invitesLabel.className = 'sv-tasks__modal-label';
        invitesLabel.textContent = 'Already shared with';

        var invitesList = document.createElement('ul');
        invitesList.className = 'sv-tasks__share-invite-list';

        invites.forEach(function (inv) {
          var li = document.createElement('li');
          li.className = 'sv-tasks__share-invite-item';

          var emailSpan = document.createElement('span');
          emailSpan.className = 'sv-tasks__share-invite-email';
          emailSpan.textContent = inv.email;

          var statusSpan = document.createElement('span');
          statusSpan.className = 'sv-tasks__share-invite-status';
          statusSpan.textContent = inv.status || 'pending';

          li.appendChild(emailSpan);
          li.appendChild(statusSpan);
          invitesList.appendChild(li);
        });

        invitesBlock.appendChild(invitesLabel);
        invitesBlock.appendChild(invitesList);
      } else {
        var noInvites = document.createElement('div');
        noInvites.className = 'sv-tasks__share-invite-empty';
        noInvites.textContent = 'Not shared with anyone yet.';
        invitesBlock.appendChild(noInvites);
      }

      form.appendChild(invitesBlock);

      var footer = document.createElement('div');
      footer.className = 'sv-tasks__modal-footer';

      var cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.addEventListener('click', function () {
        closeShareListModal();
      });

      var shareBtn = document.createElement('button');
      shareBtn.type = 'submit';
      shareBtn.textContent = 'Share';
      shareBtn.dataset.role = 'primary';

      footer.appendChild(cancelBtn);
      footer.appendChild(shareBtn);
      form.appendChild(footer);

      form.addEventListener('submit', function (event) {
        event.preventDefault();
        shareListWithEmail(numericId, inputEmail.value);
        closeShareListModal();
      });

      body.appendChild(form);

      modal.appendChild(header);
      modal.appendChild(body);

      backdrop.appendChild(modal);

      // Close when clicking on backdrop
      backdrop.addEventListener('click', function (event) {
        if (event.target === backdrop) {
          closeShareListModal();
        }
      });

      root.appendChild(backdrop);

      // Focus email input by default
      inputEmail.focus();
      inputEmail.select();
    }

    function openTaskModal(taskId) {
      var state = window.$state;
      if (!state || !state.data || !state.data.tasks) return;

      var numericId = Number(taskId);
      var task = state.data.tasks[numericId];
      if (!task) return;

      // Prevent multiple modals
      if (currentTaskModalId !== null) {
        closeTaskModal();
      }
      currentTaskModalId = numericId;

      var root = document.getElementById('sv-tasks-root');
      if (!root) return;

      var backdrop = document.createElement('div');
      backdrop.className = 'sv-tasks__modal-backdrop';
      backdrop.dataset.role = 'task-modal-backdrop';

      var modal = document.createElement('div');
      modal.className = 'sv-tasks__modal';

      var header = document.createElement('div');
      header.className = 'sv-tasks__modal-header';

      var title = document.createElement('div');
      title.className = 'sv-tasks__modal-title';
      title.textContent = 'Task details';

      var closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.className = 'sv-tasks__modal-close';
      closeBtn.innerHTML = '&times;';
      closeBtn.addEventListener('click', function () {
        closeTaskModal();
      });

      header.appendChild(title);
      header.appendChild(closeBtn);

      var body = document.createElement('div');
      body.className = 'sv-tasks__modal-body';

      var form = document.createElement('form');

      // Title field
      var fieldTitle = document.createElement('div');
      fieldTitle.className = 'sv-tasks__modal-field';
      var labelTitle = document.createElement('label');
      labelTitle.className = 'sv-tasks__modal-label';
      labelTitle.textContent = 'Title';
      var inputTitle = document.createElement('input');
      inputTitle.type = 'text';
      inputTitle.className = 'sv-tasks__modal-input';
      inputTitle.value = task.title || '';
      fieldTitle.appendChild(labelTitle);
      fieldTitle.appendChild(inputTitle);

      // Description field
      var fieldDesc = document.createElement('div');
      fieldDesc.className = 'sv-tasks__modal-field';
      var labelDesc = document.createElement('label');
      labelDesc.className = 'sv-tasks__modal-label';
      labelDesc.textContent = 'Description';
      var textareaDesc = document.createElement('textarea');
      textareaDesc.className = 'sv-tasks__modal-textarea';
      textareaDesc.value = task.description || '';
      fieldDesc.appendChild(labelDesc);
      fieldDesc.appendChild(textareaDesc);

      // Due date field
      var fieldDue = document.createElement('div');
      fieldDue.className = 'sv-tasks__modal-field';
      var labelDue = document.createElement('label');
      labelDue.className = 'sv-tasks__modal-label';
      labelDue.textContent = 'Due date';
      var inputDue = document.createElement('input');
      inputDue.type = 'date';
      inputDue.className = 'sv-tasks__modal-input';
      if (task.dueDate) {
        try {
          // Accept either full ISO or plain date strings
          var dateStr = String(task.dueDate);
          inputDue.value = dateStr.includes('T') ? dateStr.slice(0, 10) : dateStr;
        } catch (e) {
          // ignore parse errors
        }
      }
      fieldDue.appendChild(labelDue);
      fieldDue.appendChild(inputDue);

      // Recurring field
      var fieldRecurring = document.createElement('div');
      fieldRecurring.className = 'sv-tasks__modal-field';
      var labelRecurring = document.createElement('label');
      labelRecurring.className = 'sv-tasks__modal-label';
      labelRecurring.textContent = 'Repeat';

      var selectRecurring = document.createElement('select');
      selectRecurring.className = 'sv-tasks__modal-input';

      var recurringOptions = [
        { value: '', label: 'Does not repeat' },
        { value: 'daily', label: 'Every day' },
        { value: 'weekly', label: 'Every week' },
        { value: 'monthly', label: 'Every month' },
        { value: 'yearly', label: 'Every year' },
        { value: 'weekday', label: 'Every weekday (Mon–Fri)' },
        { value: 'custom', label: 'Custom…' },
      ];

      recurringOptions.forEach(function (opt) {
        var o = document.createElement('option');
        o.value = opt.value;
        o.textContent = opt.label;
        selectRecurring.appendChild(o);
      });

      // Custom recurrence: Every [N] [day/week/month/year]
      var customRecurringWrapper = document.createElement('div');
      customRecurringWrapper.className = 'flex row gap-xs align-items-center';
      customRecurringWrapper.style.marginTop = '4px';

      var customEveryLabel = document.createElement('span');
      customEveryLabel.textContent = 'Every';

      var customIntervalInput = document.createElement('input');
      customIntervalInput.type = 'number';
      customIntervalInput.min = '1';
      customIntervalInput.value = '1';
      customIntervalInput.className = 'sv-tasks__modal-input';
      customIntervalInput.style.maxWidth = '80px';

      var customUnitSelect = document.createElement('select');
      customUnitSelect.className = 'sv-tasks__modal-input';
      customUnitSelect.style.maxWidth = '120px';

      [
        { value: 'day', label: 'day' },
        { value: 'week', label: 'week' },
        { value: 'month', label: 'month' },
        { value: 'year', label: 'year' },
      ].forEach(function (opt) {
        var o = document.createElement('option');
        o.value = opt.value;
        o.textContent = opt.label;
        customUnitSelect.appendChild(o);
      });

      customRecurringWrapper.appendChild(customEveryLabel);
      customRecurringWrapper.appendChild(customIntervalInput);
      customRecurringWrapper.appendChild(customUnitSelect);

      // Custom recurrence end configuration: Ends [Does not end / On date / After N times]
      var customEndsWrapper = document.createElement('div');
      customEndsWrapper.className = 'flex row gap-xs align-items-center';
      customEndsWrapper.style.marginTop = '4px';

      var customEndsLabel = document.createElement('span');
      customEndsLabel.textContent = 'Ends';

      var customEndsSelect = document.createElement('select');
      customEndsSelect.className = 'sv-tasks__modal-input';
      customEndsSelect.style.maxWidth = '160px';

      [
        { value: 'never', label: 'Does not end' },
        { value: 'onDate', label: 'On date' },
        { value: 'afterCount', label: 'After' },
      ].forEach(function (opt) {
        var o = document.createElement('option');
        o.value = opt.value;
        o.textContent = opt.label;
        customEndsSelect.appendChild(o);
      });

      var customEndsDateInput = document.createElement('input');
      customEndsDateInput.type = 'date';
      customEndsDateInput.className = 'sv-tasks__modal-input';
      customEndsDateInput.style.maxWidth = '160px';

      var customEndsCountInput = document.createElement('input');
      customEndsCountInput.type = 'number';
      customEndsCountInput.min = '1';
      customEndsCountInput.value = '1';
      customEndsCountInput.className = 'sv-tasks__modal-input';
      customEndsCountInput.style.maxWidth = '80px';

      var customEndsCountSuffix = document.createElement('span');
      customEndsCountSuffix.textContent = 'occurrences';

      customEndsWrapper.appendChild(customEndsLabel);
      customEndsWrapper.appendChild(customEndsSelect);
      customEndsWrapper.appendChild(customEndsDateInput);
      customEndsWrapper.appendChild(customEndsCountInput);
      customEndsWrapper.appendChild(customEndsCountSuffix);

      function applyRecurringFromTask() {
        var recurring = task.recurring;
        var presetValue = '';
        var intervalValue = 1;
        var unitValue = 'day';
        var endsType = 'never';
        var endsCount = 1;
        var endsDate = '';

        if (recurring) {
          if (typeof recurring === 'string') {
            presetValue = recurring;
          } else if (typeof recurring === 'object') {
            if (recurring.kind === 'preset') {
              presetValue = recurring.preset || '';
            } else if (recurring.kind === 'custom' && recurring.custom) {
              presetValue = 'custom';
              if (typeof recurring.custom.interval === 'number' && recurring.custom.interval > 0) {
                intervalValue = recurring.custom.interval;
              }
              if (recurring.custom.unit) {
                unitValue = recurring.custom.unit;
              }
              if (recurring.custom.ends && typeof recurring.custom.ends === 'object') {
                endsType = recurring.custom.ends.type || 'never';
                if (recurring.custom.ends.type === 'afterCount' && typeof recurring.custom.ends.count === 'number') {
                  endsCount = recurring.custom.ends.count;
                } else if (recurring.custom.ends.type === 'onDate' && recurring.custom.ends.date) {
                  endsDate = recurring.custom.ends.date;
                }
              }
            }
          }
        }

        selectRecurring.value = presetValue;
        customIntervalInput.value = String(intervalValue);
        customUnitSelect.value = unitValue;

        customEndsSelect.value = endsType;
        customEndsCountInput.value = String(endsCount);
        customEndsDateInput.value = endsDate;

        updateCustomVisibility();
      }

      function updateCustomVisibility() {
        var isCustom = selectRecurring.value === 'custom';
        customRecurringWrapper.style.display = isCustom ? 'flex' : 'none';
        customEndsWrapper.style.display = isCustom ? 'flex' : 'none';

        if (!isCustom) return;

        // When custom is active, also toggle which end inputs are visible
        updateEndsVisibility();
      }

      function updateEndsVisibility() {
        var mode = customEndsSelect.value || 'never';

        if (mode === 'onDate') {
          customEndsDateInput.style.display = 'inline-block';
          customEndsCountInput.style.display = 'none';
          customEndsCountSuffix.style.display = 'none';
        } else if (mode === 'afterCount') {
          customEndsDateInput.style.display = 'none';
          customEndsCountInput.style.display = 'inline-block';
          customEndsCountSuffix.style.display = 'inline-block';
        } else {
          // never
          customEndsDateInput.style.display = 'none';
          customEndsCountInput.style.display = 'none';
          customEndsCountSuffix.style.display = 'none';
        }
      }

      selectRecurring.addEventListener('change', function () {
        updateCustomVisibility();
      });

      customEndsSelect.addEventListener('change', function () {
        updateEndsVisibility();
      });

      applyRecurringFromTask();

      fieldRecurring.appendChild(labelRecurring);
      fieldRecurring.appendChild(selectRecurring);
      fieldRecurring.appendChild(customRecurringWrapper);
      fieldRecurring.appendChild(customEndsWrapper);

      // Completed / starred checkboxes
      var fieldFlags = document.createElement('div');
      fieldFlags.className = 'sv-tasks__modal-field';
      var labelFlags = document.createElement('div');
      labelFlags.className = 'sv-tasks__modal-label';
      labelFlags.textContent = 'Status';
      var flagsRow = document.createElement('div');
      flagsRow.className = 'flex row gap-s align-items-center';

      var completedLabel = document.createElement('label');
      var completedCheckbox = document.createElement('input');
      completedCheckbox.type = 'checkbox';
      completedCheckbox.checked = !!task.completed;
      completedLabel.appendChild(completedCheckbox);
      completedLabel.appendChild(document.createTextNode(' Completed'));

      var starredLabel = document.createElement('label');
      var starredCheckbox = document.createElement('input');
      starredCheckbox.type = 'checkbox';
      starredCheckbox.checked = !!task.starred;
      starredLabel.appendChild(starredCheckbox);
      starredLabel.appendChild(document.createTextNode(' Important'));

      flagsRow.appendChild(completedLabel);
      flagsRow.appendChild(starredLabel);

      fieldFlags.appendChild(labelFlags);
      fieldFlags.appendChild(flagsRow);

      form.appendChild(fieldTitle);
      form.appendChild(fieldDesc);
      form.appendChild(fieldDue);
      form.appendChild(fieldRecurring);
      form.appendChild(fieldFlags);

      body.appendChild(form);

      var footer = document.createElement('div');
      footer.className = 'sv-tasks__modal-footer';

      var deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', function () {
        var ok = window.confirm ? window.confirm('Delete this task?') : true;
        if (!ok) return;
        deleteTask(numericId);
        closeTaskModal();
      });

      var cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.addEventListener('click', function () {
        closeTaskModal();
      });

      var saveBtn = document.createElement('button');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.dataset.role = 'primary';

      footer.appendChild(deleteBtn);
      footer.appendChild(cancelBtn);
      footer.appendChild(saveBtn);

      form.appendChild(footer);

      form.addEventListener('submit', function (event) {
        event.preventDefault();

        var recurringConfig = null;
        var mode = selectRecurring.value;

        if (mode && mode !== '') {
          if (mode === 'custom') {
            var interval = parseInt(customIntervalInput.value, 10);
            if (!interval || interval < 1) interval = 1;
            var unit = customUnitSelect.value || 'day';

            var endsMode = customEndsSelect.value || 'never';
            var ends = { type: 'never' };

            if (endsMode === 'onDate') {
              var d = customEndsDateInput.value || '';
              ends = { type: 'onDate', date: d };
            } else if (endsMode === 'afterCount') {
              var c = parseInt(customEndsCountInput.value, 10);
              if (!c || c < 1) c = 1;
              ends = { type: 'afterCount', count: c };
            }

            recurringConfig = {
              kind: 'custom',
              custom: {
                interval: interval,
                unit: unit,
                ends: ends,
              },
            };
          } else {
            recurringConfig = {
              kind: 'preset',
              preset: mode,
            };
          }
        }

        saveTaskFromModal(numericId, {
          title: inputTitle.value,
          description: textareaDesc.value,
          dueDate: inputDue.value,
          recurring: recurringConfig,
          completed: completedCheckbox.checked,
          starred: starredCheckbox.checked,
        });
      });

      modal.appendChild(header);
      modal.appendChild(body);

      backdrop.appendChild(modal);

      // Close when clicking on backdrop
      backdrop.addEventListener('click', function (event) {
        if (event.target === backdrop) {
          closeTaskModal();
        }
      });

      root.appendChild(backdrop);

      // Focus title input by default
      inputTitle.focus();
      inputTitle.select();
    }

    function closeTaskModal() {
      var root = document.getElementById('sv-tasks-root');
      if (!root) return;
      var backdrop = root.querySelector('[data-role="task-modal-backdrop"]');
      if (backdrop && backdrop.parentNode) {
        backdrop.parentNode.removeChild(backdrop);
      }
      currentTaskModalId = null;
    }

    function saveTaskFromModal(taskId, payload) {
      var state = window.$state;
      if (!state || !state.data || !state.data.tasks) return;

      var numericId = Number(taskId);
      var task = state.data.tasks[numericId];
      if (!task) return;

      var trimmedTitle = (payload.title || '').trim();
      if (!trimmedTitle) {
        // Do not allow empty title; keep existing
        trimmedTitle = task.title || '';
      }

      task.title = trimmedTitle;
      task.description = payload.description || null;
      task.dueDate = payload.dueDate || null;
      task.recurring = payload.recurring || null;
      task.completed = !!payload.completed;
      task.starred = !!payload.starred;
      task.updatedAt = nowISO();

      // Best-effort sync
      syncUpdateTask(task);

      touchUpdatedAt();
      render();
      closeTaskModal();
    }

    var dragState = {
      taskId: null,
      fromListId: null,
    };

    var listDragState = {
      listId: null,
    };

    function moveList(listId, beforeListId) {
      var state = window.$state;
      if (!state || !state.data) return;

      var listOrder = state.data.listOrder || [];
      var numericListId = Number(listId);

      // Remove the list from the current order
      var newOrder = listOrder.filter(function (id) {
        return Number(id) !== numericListId;
      });

      if (beforeListId != null) {
        var numericBeforeId = Number(beforeListId);
        var index = newOrder.findIndex(function (id) {
          return Number(id) === numericBeforeId;
        });
        if (index === -1) {
          newOrder.push(numericListId);
        } else {
          newOrder.splice(index, 0, numericListId);
        }
      } else {
        // Append to the end
        newOrder.push(numericListId);
      }

      state.data.listOrder = newOrder;
      touchUpdatedAt();
      render();
    }

    function moveTask(taskId, toListId, beforeTaskId) {
      var state = window.$state;
      if (!state || !state.data) return;

      var tasks = state.data.tasks || {};
      var taskIdsByListId = state.data.taskIdsByListId || {};

      var numericTaskId = Number(taskId);
      var numericToListId = Number(toListId);

      var task = tasks[numericTaskId];
      if (!task) return;
      if (!state.data.lists[numericToListId]) return;

      var fromListId = task.listId;
      var numericFromListId = Number(fromListId);

      // Remove from old list array
      var fromListTaskIds = taskIdsByListId[numericFromListId] || [];
      taskIdsByListId[numericFromListId] = fromListTaskIds.filter(function (id) {
        return Number(id) !== numericTaskId;
      });

      // Insert into new list array, either before a specific task or at the end
      var toListTaskIds = taskIdsByListId[numericToListId] || [];
      var index = -1;
      if (beforeTaskId != null) {
        var numericBeforeId = Number(beforeTaskId);
        index = toListTaskIds.findIndex(function (id) {
          return Number(id) === numericBeforeId;
        });
      }
      if (index === -1) {
        toListTaskIds.push(numericTaskId);
      } else {
        toListTaskIds.splice(index, 0, numericTaskId);
      }
      taskIdsByListId[numericToListId] = toListTaskIds;

      // Update task's listId
      task.listId = numericToListId;
      task.updatedAt = nowISO();

      state.data.taskIdsByListId = taskIdsByListId;
      touchUpdatedAt();
      render();
    }

    function closeAllListMenus() {
      var root = document.getElementById('sv-tasks-root');
      if (!root) return;
      var menus = root.querySelectorAll('.sv-tasks__list-menu');
      menus.forEach(function (menu) {
        if (menu.parentNode) {
          menu.parentNode.removeChild(menu);
        }
      });
    }

    function sortTasksInList(listId, mode) {
      var state = window.$state;
      if (!state || !state.data) return;

      var tasks = state.data.tasks || {};
      var taskIdsByListId = state.data.taskIdsByListId || {};
      var numericListId = Number(listId);
      var taskIds = (taskIdsByListId[numericListId] || []).slice();

      if (!taskIds.length) return;

      taskIds.sort(function (a, b) {
        var ta = tasks[a];
        var tb = tasks[b];
        if (!ta && !tb) return 0;
        if (!ta) return 1;
        if (!tb) return -1;

        if (mode === 'title') {
          var at = (ta.title || '').toLowerCase();
          var bt = (tb.title || '').toLowerCase();
          if (at < bt) return -1;
          if (at > bt) return 1;
          return 0;
        }

        if (mode === 'dueDate') {
          var ad = ta.dueDate ? new Date(ta.dueDate).getTime() : Infinity;
          var bd = tb.dueDate ? new Date(tb.dueDate).getTime() : Infinity;
          if (ad < bd) return -1;
          if (ad > bd) return 1;
          return 0;
        }

        // Default: createdAt ascending
        var ac = ta.createdAt ? new Date(ta.createdAt).getTime() : 0;
        var bc = tb.createdAt ? new Date(tb.createdAt).getTime() : 0;
        if (ac < bc) return -1;
        if (ac > bc) return 1;
        return 0;
      });

      taskIdsByListId[numericListId] = taskIds;
      state.data.taskIdsByListId = taskIdsByListId;

      touchUpdatedAt();
      render();
    }

    function render() {
      const root = document.getElementById('sv-tasks-root');
      if (!root || !window.$state || !window.$state.data) return;

      const board = root.querySelector('[data-role="board"]');
      if (!board) return;

      // Clear current board content so we can re-render from state
      board.innerHTML = '';

      const { lists, tasks, taskIdsByListId, listOrder } = window.$state.data;
      const currentFilter = (window.$state.ui && window.$state.ui.taskFilter) || 'all';

      // Render each list as a column
      (listOrder || Object.keys(lists)).forEach(function (id) {
        const listId = Number(id);
        const list = lists[listId];
        if (!list) return;

        const listEl = document.createElement('article');
        listEl.className = 'sv-tasks__list';
        listEl.dataset.listId = String(listId);

        // List drag-and-drop handlers
        listEl.draggable = true;
        listEl.addEventListener('dragstart', function (event) {
          listDragState.listId = listId;
          event.dataTransfer.effectAllowed = 'move';
          listEl.classList.add('sv-tasks__list--dragging');
        });

        listEl.addEventListener('dragend', function () {
          listDragState.listId = null;
          listEl.classList.remove('sv-tasks__list--dragging');
        });

        listEl.addEventListener('dragover', function (event) {
          if (!listDragState.listId || listDragState.listId === listId) return;
          event.preventDefault();
        });

        listEl.addEventListener('drop', function (event) {
          if (!listDragState.listId || listDragState.listId === listId) return;
          event.preventDefault();
          moveList(listDragState.listId, listId);
        });

        const headerEl = document.createElement('header');
        headerEl.className = 'sv-tasks__list-header flex row align-items-center flex-space-between';

        const titleEl = document.createElement('h2');
        titleEl.className = 'sv-h-5 sv-tasks__list-title';
        titleEl.textContent = list.name;

        // Shared status pill: show if this list has share invites
        var shareMap = (window.$state && window.$state.data && window.$state.data.shareInvitesByListId) || {};
        var listInvites = shareMap[listId];
        if (listInvites && listInvites.length > 0) {
          var pill = document.createElement('span');
          pill.className = 'sv-tasks__list-shared-pill';
          pill.textContent = 'Shared';
          titleEl.appendChild(pill);
        }

        titleEl.addEventListener('click', function () {
          var input = document.createElement('input');
          input.type = 'text';
          input.value = list.name;
          input.className = 'sv-tasks__list-title-input';

          function commit() {
            renameList(listId, input.value);
          }

          input.addEventListener('keydown', function (event) {
            if (event.key === 'Enter') {
              commit();
            } else if (event.key === 'Escape') {
              render();
            }
          });

          input.addEventListener('blur', function () {
            commit();
          });

          headerEl.replaceChild(input, titleEl);
          input.focus();
          input.select();
        });

        const menuButton = document.createElement('button');
        menuButton.type = 'button';
        menuButton.className = 'sv-icon-button sv-tasks__list-menu-button';
        menuButton.setAttribute('aria-label', 'List actions');
        menuButton.dataset.action = 'open-list-menu';
        menuButton.textContent = '⚙';

        menuButton.addEventListener('click', function (event) {
          event.stopPropagation();

          // Toggle menu: if already open for this header, close it
          var existing = headerEl.querySelector('.sv-tasks__list-menu');
          if (existing) {
            existing.parentNode.removeChild(existing);
            return;
          }

          closeAllListMenus();

          var menu = document.createElement('div');
          menu.className = 'sv-tasks__list-menu';
          menu.dataset.role = 'list-menu';

          function addItem(label, handler, variant) {
            var item = document.createElement('button');
            item.type = 'button';
            item.className = 'sv-tasks__list-menu-item';
            item.textContent = label;
            if (variant) {
              item.dataset.variant = variant;
            }
            item.addEventListener('click', function (e) {
              e.stopPropagation();
              handler();
              closeAllListMenus();
            });
            menu.appendChild(item);
          }

          addItem('Share list…', function () {
            openShareListModal(listId);
          });

          addItem('Sort by created time', function () {
            sortTasksInList(listId, 'createdAt');
          });

          addItem('Sort by title (A–Z)', function () {
            sortTasksInList(listId, 'title');
          });

          addItem('Sort by due date', function () {
            sortTasksInList(listId, 'dueDate');
          });

          addItem('Delete completed tasks', function () {
            var ok = window.confirm
              ? window.confirm('Delete all completed tasks in "' + list.name + '"?')
              : true;
            if (!ok) return;
            deleteCompletedTasksInList(listId);
          });

          var divider = document.createElement('div');
          divider.className = 'sv-tasks__list-menu-divider';
          menu.appendChild(divider);

          addItem('Delete list', function () {
            var ok = window.confirm
              ? window.confirm('Delete list "' + list.name + '" and all its tasks?')
              : true;
            if (ok) {
              deleteList(listId);
            }
          }, 'danger');

          headerEl.appendChild(menu);
        });

        headerEl.appendChild(titleEl);
        headerEl.appendChild(menuButton);

        const bodyEl = document.createElement('div');
        bodyEl.className = 'sv-tasks__list-body flex col gap-xs';

        // Enable dropping tasks into this list body
        bodyEl.addEventListener('dragover', function (event) {
          if (!dragState.taskId) return;
          event.preventDefault();
        });

        bodyEl.addEventListener('drop', function (event) {
          if (!dragState.taskId) return;
          event.preventDefault();
          moveTask(dragState.taskId, listId, null);
        });

        // Render tasks for this list, if any
        const taskIds = (taskIdsByListId && taskIdsByListId[listId]) || [];

        // Keep active tasks first and completed tasks at the bottom,
        // while preserving original relative order inside each group.
        var orderedTaskIds = [];
        var completedTaskIds = [];

        taskIds.forEach(function (taskId) {
          var task = tasks && tasks[taskId];
          if (!task) return;
          if (task.completed) {
            completedTaskIds.push(taskId);
          } else {
            orderedTaskIds.push(taskId);
          }
        });

        orderedTaskIds = orderedTaskIds.concat(completedTaskIds);

        orderedTaskIds.forEach(function (taskId) {
          var task = tasks && tasks[taskId];
          if (!task) return;
          if (currentFilter === 'active' && task.completed) {
            return;
          }
          if (currentFilter === 'completed' && !task.completed) {
            return;
          }

          var taskCard = document.createElement('div');
          taskCard.className = 'sv-tasks__task-card';
          taskCard.dataset.taskId = String(taskId);
          taskCard.draggable = true;

          taskCard.addEventListener('dragstart', function (event) {
            dragState.taskId = taskId;
            dragState.fromListId = listId;
            event.dataTransfer.effectAllowed = 'move';
            taskCard.classList.add('sv-tasks__task-card--dragging');
          });

          taskCard.addEventListener('dragend', function () {
            dragState.taskId = null;
            dragState.fromListId = null;
            taskCard.classList.remove('sv-tasks__task-card--dragging');
          });

          // Allow dropping another task before this card
          taskCard.addEventListener('dragover', function (event) {
            if (!dragState.taskId) return;
            event.preventDefault();
          });

          taskCard.addEventListener('drop', function (event) {
            if (!dragState.taskId) return;
            event.preventDefault();
            // Move dragged task into this list, before this task
            moveTask(dragState.taskId, listId, taskId);
          });

          var taskMain = document.createElement('div');
          taskMain.className = 'sv-tasks__task-main flex row gap-xs align-items-center';

          var checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.className = 'sv-tasks__task-checkbox';
          checkbox.dataset.action = 'toggle-completed';
          checkbox.checked = !!task.completed;
          checkbox.addEventListener('change', function () {
            toggleTaskCompleted(taskId);
          });

          var starButton = document.createElement('button');
          starButton.type = 'button';
          starButton.className = 'sv-icon-button sv-tasks__task-star';
          starButton.dataset.action = 'toggle-starred';
          starButton.setAttribute('aria-label', 'Mark as important');
          starButton.textContent = task.starred ? '★' : '☆';
          starButton.addEventListener('click', function () {
            toggleTaskStarred(taskId);
          });

          var content = document.createElement('div');
          content.className = 'sv-tasks__task-content flex col gap-2xs';

          var titleNode = document.createElement('div');
          titleNode.className = 'sv-tasks__task-title';
          titleNode.textContent = task.title;

          var meta = document.createElement('div');
          meta.className = 'sv-tasks__task-meta';
          if (task.dueDate) {
            var timeEl = document.createElement('time');
            timeEl.dateTime = task.dueDate;
            var pretty = formatDueDateDisplay(task.dueDate);
            timeEl.textContent = pretty;
            timeEl.title = String(task.dueDate);
            meta.appendChild(timeEl);
          }

          if (task.recurring) {
            var recurSpan = document.createElement('span');
            var label = '';
            var details = '';
            var r = task.recurring;

            if (typeof r === 'string') {
              if (r === 'daily') label = 'Repeats daily';
              else if (r === 'weekly') label = 'Repeats weekly';
              else if (r === 'monthly') label = 'Repeats monthly';
              else if (r === 'yearly') label = 'Repeats yearly';
              else if (r === 'weekday') label = 'Repeats on weekdays';
              else label = 'Repeats';
            } else if (typeof r === 'object') {
              if (r.kind === 'preset') {
                switch (r.preset) {
                  case 'daily':
                    label = 'Repeats daily';
                    break;
                  case 'weekly':
                    label = 'Repeats weekly';
                    break;
                  case 'monthly':
                    label = 'Repeats monthly';
                    break;
                  case 'yearly':
                    label = 'Repeats yearly';
                    break;
                  case 'weekday':
                    label = 'Repeats on weekdays';
                    break;
                  default:
                    label = 'Repeats';
                    break;
                }
              } else if (r.kind === 'custom' && r.custom) {
                var iv = r.custom.interval || 1;
                var unit = r.custom.unit || 'day';
                var unitLabel = unit;
                if (iv !== 1) {
                  if (unit === 'day') unitLabel = 'days';
                  else if (unit === 'week') unitLabel = 'weeks';
                  else if (unit === 'month') unitLabel = 'months';
                  else if (unit === 'year') unitLabel = 'years';
                }
                label = 'Every ' + iv + ' ' + unitLabel;

                // Ends hints for custom recurrences
                if (r.custom.ends && typeof r.custom.ends === 'object') {
                  var ends = r.custom.ends;
                  var type = ends.type || 'never';
                  if (type === 'afterCount') {
                    var count = parseInt(ends.count, 10);
                    if (count && count > 0) {
                      details = ' (' + count + ' left)';
                    }
                  } else if (type === 'onDate' && ends.date) {
                    var endDate = parseDateFlexible(ends.date);
                    if (endDate && !Number.isNaN(endDate.getTime())) {
                      try {
                        var opts = { day: 'numeric', month: 'short' };
                        var formatted = endDate.toLocaleDateString(undefined, opts);
                        details = ' (Ends on ' + formatted + ')';
                      } catch (e) {
                        details = ' (Ends on ' + String(ends.date) + ')';
                      }
                    } else {
                      details = ' (Ends on ' + String(ends.date) + ')';
                    }
                  }
                }
              }
            }

            if (label) {
              if (meta.childNodes.length > 0) {
                recurSpan.style.marginLeft = '0.25rem';
              }
              recurSpan.textContent = '• ' + label + details;
              meta.appendChild(recurSpan);
            }
          }

          content.appendChild(titleNode);
          if (meta.childNodes.length > 0) {
            content.appendChild(meta);
          }

          // Open details modal when clicking on the content area
          content.addEventListener('click', function () {
            openTaskModal(taskId);
          });

          taskMain.appendChild(checkbox);
          taskMain.appendChild(starButton);
          taskMain.appendChild(content);

          // Quick delete button on the card
          var deleteBtn = document.createElement('button');
          deleteBtn.type = 'button';
          deleteBtn.className = 'sv-icon-button sv-tasks__task-delete';
          deleteBtn.setAttribute('aria-label', 'Delete task');
          deleteBtn.textContent = '🗑';
          deleteBtn.addEventListener('click', function (event) {
            event.stopPropagation();
            var ok = window.confirm ? window.confirm('Delete this task?') : true;
            if (!ok) return;
            deleteTask(taskId);
          });

          taskMain.appendChild(deleteBtn);

          taskCard.appendChild(taskMain);
          if (task.completed) {
            taskCard.classList.add('sv-tasks__task-card--completed');
          }
          if (task.starred) {
            taskCard.classList.add('sv-tasks__task-card--starred');
          }
          bodyEl.appendChild(taskCard);
        });

        const addTaskEl = document.createElement('div');
        addTaskEl.className = 'sv-tasks__add-task';
        const addTaskInput = document.createElement('input');
        addTaskInput.type = 'text';
        addTaskInput.className = 'sv-tasks__add-task-input';
        addTaskInput.placeholder = 'Add task…';
        addTaskInput.dataset.role = 'add-task-input';

        addTaskInput.addEventListener('keydown', function (event) {
          if (event.key === 'Enter') {
            addTask(listId, addTaskInput.value);
            addTaskInput.value = '';
          }
        });

        addTaskEl.appendChild(addTaskInput);

        listEl.appendChild(headerEl);
        // Add-task input at the top of the column, just under the header
        listEl.appendChild(addTaskEl);
        listEl.appendChild(bodyEl);

        board.appendChild(listEl);
      });

      // Add-list column at the end of the board
      var addListColumn = document.createElement('article');
      addListColumn.className = 'sv-tasks__add-list';
      addListColumn.dataset.role = 'add-list-column';

      addListColumn.addEventListener('dragover', function (event) {
        if (!listDragState.listId) return;
        event.preventDefault();
      });

      addListColumn.addEventListener('drop', function (event) {
        if (!listDragState.listId) return;
        event.preventDefault();
        moveList(listDragState.listId, null);
      });

      var addListInput = document.createElement('input');
      addListInput.type = 'text';
      addListInput.className = 'sv-tasks__add-list-input';
      addListInput.placeholder = 'New list…';
      addListInput.dataset.role = 'add-list-input';

      addListInput.addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
          addList(addListInput.value);
          addListInput.value = '';
        }
      });

      addListColumn.appendChild(addListInput);
      board.appendChild(addListColumn);

      applyTaskFilterUI();
    }

    function deleteTask(taskId) {
      var state = window.$state;
      if (!state || !state.data) return;

      var tasks = state.data.tasks || {};
      var taskIdsByListId = state.data.taskIdsByListId || {};

      var numericTaskId = Number(taskId);
      var task = tasks[numericTaskId];
      if (!task) return;

      var listId = Number(task.listId);
      var listTaskIds = taskIdsByListId[listId] || [];

      // Remove task from list mapping
      taskIdsByListId[listId] = listTaskIds.filter(function (id) {
        return Number(id) !== numericTaskId;
      });

      // Remove task record
      delete tasks[numericTaskId];

      state.data.tasks = tasks;
      state.data.taskIdsByListId = taskIdsByListId;

      touchUpdatedAt();
      render();
      // Best-effort sync
      syncDeleteTask(numericTaskId);
    }

    function deleteCompletedTasksInList(listId) {
      var state = window.$state;
      if (!state || !state.data) return;

      var tasks = state.data.tasks || {};
      var taskIdsByListId = state.data.taskIdsByListId || {};
      var numericListId = Number(listId);

      var listTaskIds = taskIdsByListId[numericListId] || [];
      if (!listTaskIds.length) return;

      // Filter out completed tasks and delete them from the tasks map
      var remainingTaskIds = [];
      listTaskIds.forEach(function (id) {
        var numericTaskId = Number(id);
        var task = tasks[numericTaskId];
        if (task && task.completed) {
          delete tasks[numericTaskId];
        } else {
          remainingTaskIds.push(id);
        }
      });

      taskIdsByListId[numericListId] = remainingTaskIds;
      state.data.tasks = tasks;
      state.data.taskIdsByListId = taskIdsByListId;

      touchUpdatedAt();
      render();
      // Best-effort sync
      syncDeleteCompletedTasks(numericListId);
    }

    function deleteList(listId) {
      var state = window.$state;
      if (!state || !state.data) return;

      var lists = state.data.lists || {};
      var tasks = state.data.tasks || {};
      var taskIdsByListId = state.data.taskIdsByListId || {};
      var listOrder = state.data.listOrder || [];

      var numericId = Number(listId);
      if (!lists[numericId]) return;

      // Prevent deleting the last remaining list
      if (Object.keys(lists).length <= 1) {
        if (window.alert) {
          window.alert('You must have at least one list.');
        }
        return;
      }

      // Remove tasks belonging to this list
      var idsToRemove = taskIdsByListId[numericId] || [];
      idsToRemove.forEach(function (taskId) {
        delete tasks[taskId];
      });
      delete taskIdsByListId[numericId];

      // Remove the list and update ordering
      delete lists[numericId];
      listOrder = listOrder.filter(function (id) {
        return Number(id) !== numericId;
      });

      state.data.lists = lists;
      state.data.tasks = tasks;
      state.data.taskIdsByListId = taskIdsByListId;
      state.data.listOrder = listOrder;

      touchUpdatedAt();
      render();
      // Best-effort sync
      syncDeleteList(numericId);
    }

    function bootstrapFromServer() {
      if (typeof fetch !== 'function') return;

      // Respect offline-first: do not attempt if the browser thinks it's offline
      if (typeof navigator !== 'undefined' && navigator && navigator.onLine === false) {
        return;
      }

      try {
        fetch('/api/plugins/tasks/bootstrap', {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
          },
          credentials: 'same-origin',
        })
          .then(function (res) {
            if (!res || !res.ok) {
              return null;
            }
            return res.json();
          })
          .then(function (payload) {
            if (!payload || !payload.lists || !payload.tasks) {
              return;
            }

            var now = nowISO();
            var listsArray = Array.isArray(payload.lists) ? payload.lists : [];
            var tasksArray = Array.isArray(payload.tasks) ? payload.tasks : [];

            if (!listsArray.length) {
              return;
            }

            var listsMap = {};
            var taskIdsByListId = {};
            var listOrder = [];
            var remoteListIds = {};

            listsArray.forEach(function (list) {
              if (!list || typeof list.id === 'undefined') return;
              var id = Number(list.id);
              if (Number.isNaN(id)) return;

              var createdAt = list.createdAt || now;
              var updatedAt = list.updatedAt || now;

              listsMap[id] = {
                id: id,
                name: list.name || ('List ' + id),
                slug: list.slug || String(list.name || ('list-' + id)).toLowerCase().replace(/\s+/g, '-'),
                createdAt: createdAt,
                updatedAt: updatedAt,
                // Server-side ID mirror
                remoteId: id,
              };
              remoteListIds[id] = id;
              taskIdsByListId[id] = [];
              listOrder.push(id);
            });

            var tasksMap = {};
            tasksArray.forEach(function (task) {
              if (!task || typeof task.id === 'undefined') return;
              var id = Number(task.id);
              if (Number.isNaN(id)) return;

              var listId = Number(task.listId);
              if (Number.isNaN(listId) || !listsMap[listId]) return;

              var createdAt = task.createdAt || now;
              var updatedAt = task.updatedAt || now;

              var rec = null;
              if (task.recurringConfig) {
                rec = task.recurringConfig;
              } else if (task.recurring) {
                rec = task.recurring;
              }

              var due = null;
              if (task.dueDate) {
                var dueStr = String(task.dueDate);
                due = dueStr.includes('T') ? dueStr.slice(0, 10) : dueStr;
              }

              tasksMap[id] = {
                id: id,
                listId: listId,
                title: task.title || '',
                description: task.description || null,
                dueDate: due,
                recurring: rec || null,
                completed: !!task.completed,
                starred: !!task.starred,
                createdAt: createdAt,
                updatedAt: updatedAt,
                // Server-side IDs: these tasks come from the server,
                // so their local id is also the remote id.
                remoteId: id,
                remoteListId: listId,
              };

              if (!taskIdsByListId[listId]) {
                taskIdsByListId[listId] = [];
              }
              taskIdsByListId[listId].push(id);
            });

            var shareInvitesByListId = {};
            if (Array.isArray(payload.invites)) {
              payload.invites.forEach(function (invite) {
                var lid = invite.listId;
                if (!shareInvitesByListId[lid]) {
                  shareInvitesByListId[lid] = [];
                }
                shareInvitesByListId[lid].push({
                  id: invite.id,
                  email: invite.email,
                  status: invite.status,
                });
              });
            }

            var nextState = {
              meta: {
                createdAt: (window.$state && window.$state.meta && window.$state.meta.createdAt) || now,
                updatedAt: (payload.meta && payload.meta.updatedAt) || now,
                version: CURRENT_VERSION,
              },
              data: {
                lists: listsMap,
                tasks: tasksMap,
                taskIdsByListId: taskIdsByListId,
                listOrder: listOrder,
                shareInvitesByListId: shareInvitesByListId,
              },
              ui: (window.$state && window.$state.ui) || { taskFilter: 'all' },
              sync: {
                lastServerBootstrapAt: now,
                remoteListIds: remoteListIds,
              },
            };

            window.$state = migrateState(nextState);
            saveState();
            render();
            applyTaskFilterUI();
          })
          .catch(function () {
            // Silently ignore network / parsing errors to preserve offline-first behaviour
          });
      } catch (e) {
        // Ignore environments without fetch or unexpected failures
      }
    }

    function resetState() {
      if (canUseLocalStorage()) {
        try {
          window.localStorage.removeItem(STORAGE_KEY);
        } catch (e) {
          // ignore
        }
      }
      window.$state = null;
      initState();
      render();
      applyTaskFilterUI();
    }

    document.addEventListener('DOMContentLoaded', function () {
      initState();
      render();
      applyTaskFilterUI();

      // If this looks like a fresh/default state (single Inbox, no tasks),
      // try to hydrate from the server once, without breaking offline use.
      if (isLikelyEmptyState(window.$state)) {
        bootstrapFromServer();
      }

      var filterButtons = document.querySelectorAll('.sv-tasks__filter-button');
      filterButtons.forEach(function (btn) {
        btn.addEventListener('click', function () {
          var filter = btn.dataset.filter;
          setTaskFilter(filter);
        });
      });

      // Close any open list menus when clicking outside
      document.addEventListener('click', function () {
        closeAllListMenus();
      });
    });

    // Expose for debugging in the console
    window.SvTasks = {
      initState: initState,
      render: render,
      addList: addList,
      renameList: renameList,
      addTask: addTask,
      toggleTaskCompleted: toggleTaskCompleted,
      toggleTaskStarred: toggleTaskStarred,
      moveTask: moveTask,
      moveList: moveList,
      setTaskFilter: setTaskFilter,
      deleteList: deleteList,
      deleteTask: deleteTask,
      deleteCompletedTasksInList: deleteCompletedTasksInList,
      saveState: saveState,
      loadState: loadState,
      resetState: resetState,
      openTaskModal: openTaskModal,
      closeTaskModal: closeTaskModal,
      version: CURRENT_VERSION,
    };
  })();
</script>
